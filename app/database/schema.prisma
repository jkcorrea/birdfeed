datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
  directUrl         = env("DIRECT_DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["extendedWhereUnique", "orderByNulls"]
}

// Disclaimer: This schema is designed for a 3 tiers subscription app (free, tier_1, tier_2)
// Each tier has a monthly and yearly price in usd and eur
// Adapt it to your needs and don't forget to prisma generate after changes
// You certainly will need to adapt the code, the seeding script and other stripe scripts I made (in the scripts folder)
// It will be easier to start from scratch if you made a lot of changes (recreating Supabase DB and erasing Stripe tests data)

// Models
model User {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  email      String @unique

  twitterOAuthToken       String?
  twitterOAuthTokenSecret String?

  transcript   Transcript[]

  stripeCustomerId String @unique // Created by Stripe
  stripeSubscriptionId  String // Created by Stripe

  @@map("users")
}

model Price {
  stripePriceId String @id
  stripeProductId String
  stripeInterval String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt @default(now())

  @@map("prices")
}

model Transcript {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name           String
  pathInBucket   String?
  content        String
  neverGenerated Boolean @default(true)

  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tweets Tweet[]

  @@map("transcripts")
}

model Tweet {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  drafts   String[]
  document String
  sendAt   DateTime?
  sent     Boolean   @default(false)
  rating   Int?
  archived Boolean   @default(false)

  transcript   Transcript @relation(fields: [transcriptId], references: [id], onDelete: Cascade)
  transcriptId String

  @@map("tweets")
}

// #region BILLING


enum TokenType {
  ANON_CHECKOUT_TOKEN
  AUTH_CHECKOUT_TOKEN
}

// Tokens require a type.  The schema of the metadata is dependent on the type
model Token {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  active    Boolean  @default(true)
  token     String
  type        TokenType
  expiresAt   DateTime?
  metadata Json @default("{}")
  @@map("tokens")
  @@unique([token, type])
}
